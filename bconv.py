#!/usr/bin/env python

#######################################
# methylCtools bconv
# v1.1.0
# 26 march 2022
#
# volker hovestadt
# developed at the german cancer research center, 2011-2015
# methylctools@hovestadt.bio
#
#
# reads are converted back to original state. positions are stored in read id.
# if a read (pair) maps illegally (reverse to Watson strand/forward to Crick
# strand, assuming strand specific protocol) it is set QCfail (flag +512).
# if there are more than INT non-CpG unconverted cytosines within the aligned part
# of a read, the read/pair is set QCfail.
#
# input must be in BAM format (unsorted (!) bwa output, use "-" for stdin).
# output is in BAM format, use "-" for stdout.


def mod_bconv(sysargv):
	import sys
	import argparse
	import pysam
	import re
	import datetime
	def nicetime(): return datetime.datetime.now().strftime("[bconv %Y-%m-%d %H:%M:%S]")


	#######################################
	# arguments, filehandles

	parser = argparse.ArgumentParser(prog="methylCtools bconv", version="0.9.4", description="re-converts reads to original state following bwa alignment")
	parser.add_argument("-s", "--silent", dest="qf", action="store_false", help="do not show status messages")
	parser.add_argument("-m", "--metrics", metavar="metrics.txt", dest="outMETRICS", action="store", default=False, help="write metrics output")

	groupinput = parser.add_argument_group("input files, required")
	groupinput.add_argument("inBAM", metavar="aln.conv.bam", action="store", default=False, help="bwa alignment (unsorted), \"-\" for stdin")
	
	groupoutput = parser.add_argument_group("output files, will be created")
	groupoutput.add_argument("outBAM", metavar="aln.bam", action="store", default=False, help="converted alignment, \"-\" for stdout")

	parser.add_argument("-u", "--maxunconv", metavar="INT", dest="maxnCGc", type=int, default=False, action="store", help="set reads containing > INT non-CG unconverted cytosines qc-fail [off]")

	args = parser.parse_args(sysargv)

	try:
		samfileIN = pysam.Samfile(args.inBAM, "rb")
		
		h = samfileIN.header												# construct new header (merge alignments from Watson and Crick strand of same contig) 
		hseqnew = []
		
		for tid in range(len(h["SQ"])):										# header should be in the order of reference file generated by faconv, otherwise exit
			if tid%2==0:
				if h["SQ"][tid]["SN"][-2:] != "_W": sys.exit("methylCtools bconv: error: invalid BAM header")
				hseqnew.append(h["SQ"][tid])
				hseqnew[-1]["SN"] = h["SQ"][tid]["SN"][:-2]
			else:
				if h["SQ"][tid]["SN"][-2:] != "_C": sys.exit("methylCtools bconv: error: invalid BAM header")
		h["SQ"] = hseqnew

		if args.outBAM == "-":
			samfileOUT = pysam.Samfile(args.outBAM, "wbu", header=h)
		else:
			samfileOUT = pysam.Samfile(args.outBAM, "wb", header=h)

		if args.outMETRICS:
			metricsOUT = open(args.outMETRICS, "w")

	except IOError as strerror:
		sys.exit("methylCtools bconv: error: %s" % strerror)
	
	if args.qf: sys.stderr.write("%s command: %s\n" % (nicetime(), " ".join(sys.argv)))
	

	#######################################
	# define functions	
	
	def setQCfail(read):
		if not read.is_qcfail:
			read.flag += 512
			c[6] += 1
		return read		
		
	def convert(p, s, r):													# p: conversion positions, s: sequence, r: is_reverse
		pp = bin(int(p, 16)).lstrip("0b")
		pp = "0" * (len(s)-len(pp)) + pp
		if r: pp = pp[::-1]
		for i in re.finditer("1", pp):
			pi = i.start()
			if s[pi] == "T": s = s[:pi] + "C" + s[pi+1:]
			elif s[pi] == "A": s = s[:pi] + "G" + s[pi+1:]
			else: sys.exit("methylCtools bconv: error: unexpected conversion")
 		return s

	def changetid(t):
		if t >= 0:
			if t%2 == 0: return t/2
			else: return (t-1)/2
		else: return t


	#######################################
	# main

	if args.qf: sys.stderr.write("%s start: processing alignments\n" % nicetime())
	c = [0] *9																# [reads, paired, mapped, qcfail, proper, singleton, illegal, nCGc, isize<readlen]
	isized = [0] *501														# insert size distribution
	tidd = [0] *len(hseqnew)
	
	while 1:
		try:
			read1 = samfileIN.next()
			while read1.is_secondary: read1 = samfileIN.next()				# do not process secondary alignments (bwa-mem)
		except StopIteration: break
		
		if read1.is_paired:
			### PE read
			try:
				read2 = samfileIN.next()
				while read2.is_secondary: read2 = samfileIN.next()
			except StopIteration: break
			
			# convert
			read1Q, read2Q = read1.qname.split("."), read2.qname.split(".")
			read1H = read1Q[1]
			if len(read2Q) == 3: read2H = read2Q[2]
			else: read2H = read2Q[1]
			if read1Q[0] != read2Q[0]: sys.exit("methylCtools bconv: error: input read order: %s, %s" % (read1Q[0], read2Q[0]))
			read1.qname, read2.qname = read1Q[0], read2Q[0]					# restore original ID			
			read1qual, read2qual = read1.qual, read2.qual					# pysam "bug": qual is reset when seq is changed		
			read1.seq = convert(read1H, read1.seq, read1.is_reverse)
			read2.seq = convert(read2H, read2.seq, read2.is_reverse)			
			read1.qual, read2.qual = read1qual, read2qual			
			
			# check for illegal mapping
			for read in [read1, read2]:
				if not read.is_unmapped:
					if read.tid%2 == 0:
						if read.is_read1:				# 99
							if read.is_reverse:
								setQCfail(read1), setQCfail(read2)
						else:							# 147
							if not read.is_reverse:
								setQCfail(read1), setQCfail(read2)
					else:
						if read.is_read1:				# 83
							if not read.is_reverse:
								setQCfail(read1), setQCfail(read2)
						else:
							if read.is_reverse:			# 163
								setQCfail(read1), setQCfail(read2)

			# check for unconverted non-CpGs
			if not type(args.maxnCGc) == type(False):
				nCGc1, nCGc2 = 0, 0	
				
				if not read1.is_unmapped:
					if read1.is_read1 != read1.is_reverse: nCGc1 = len([s2 for s2 in re.findall("C[A,C,T]", read1.query)])
					else: nCGc1 = len([s2 for s2 in re.findall("[A,G,T]G", read1.query)])
				if not read2.is_unmapped: 
					if read2.is_read1 != read2.is_reverse: nCGc2 = len([s2 for s2 in re.findall("C[A,C,T]", read2.query)])
					else: nCGc2 = len([s2 for s2 in re.findall("[A,G,T]G", read2.query)])
			
				if nCGc1 > args.maxnCGc or nCGc2 > args.maxnCGc:
					if not read1.is_qcfail: read1.flag += 512
					if not read2.is_qcfail: read2.flag += 512
					c[7] += 2

			# change tid
			read1.tid = changetid(read1.tid)
			read1.mrnm = changetid(read1.mrnm)
			read2.tid = changetid(read2.tid)
			read2.mrnm = changetid(read2.mrnm)
			
			# write
			samfileOUT.write(read1)
			samfileOUT.write(read2)
			
			# metrics
			c[0] += 2														# reads
			if args.outMETRICS:
				c[1] += 2													# paired
				for read in [read1, read2]:
					if read.is_proper_pair:
						c[4] += 1											# proper pair
						c[2] += 1
						tidd[read.tid] += 1
					elif not read.is_unmapped:
						c[2] += 1											# mapped
						if read.mate_is_unmapped: c[5] += 1					# singleton
						elif read.tid == read.mrnm and read.pos == read.mpos: c[8] += 1		# isize < read length
						tidd[read.tid] += 1									
					if not read.isize == 0 and abs(read.isize) <= 500:
						isized[abs(read.isize)] += 1						# isize					
					if read.is_qcfail: c[3] += 1							# qcfail					
					
			if args.qf and c[0]%10**6 <= 1: sys.stderr.write("%s status: %i alignments processed\n" % (nicetime(), c[0]))

		else:
			### SE read
			if read1.is_secondary: continue

			# convert
			read1Q = read1.qname.split(".")
			read1H = read1Q[1]
			read1.qname = read1Q[0]											# restore original ID			
			read1qual = read1.qual											# pysam "bug": qual is reset when seq is changed		
			read1.seq = convert(read1H, read1.seq, read1.is_reverse)		
			read1.qual = read1qual			
			
			# check for illegal mapping
			if not read1.is_unmapped:
				if read1.tid%2 == 0:
					if read1.is_reverse:				# 0
						setQCfail(read1)
				else:
					if not read1.is_reverse:			# 16
						setQCfail(read1)

			# check for unconverted non-CpGs
			if not type(args.maxnCGc) == type(False):
				nCGc1 = 0
			
				if not read1.is_unmapped:
					if not read1.is_reverse: nCGc1 = len([s2 for s2 in re.findall("C[A,C,T]", read1.query)])
					else: nCGc1 = len([s2 for s2 in re.findall("[A,G,T]G", read1.query)])
					
				if nCGc1 > args.maxnCGc:
					if not read1.is_qcfail: read1.flag += 512
					c[7] += 1
			
			# change tid
			read1.tid = changetid(read1.tid)
			read1.mrnm = changetid(read1.mrnm)
			
			# write
			samfileOUT.write(read1)

			# metrics
			c[0] += 1														# reads
			if args.outMETRICS:
				if not read1.is_unmapped:
					c[2] += 1												# mapped
					tidd[read1.tid] += 1									# tid			
				if read1.is_qcfail: c[3] += 1								# qcfail					

			if args.qf and c[0]%10**6 == 0: sys.stderr.write("%s status: %i alignments processed\n" % (nicetime(), c[0]))
		

	#######################################
	# end
	
	if args.outMETRICS:
		metricsOUT.write("# flag statistics\n")
		metricsOUT.write("%10i  in total\n" % c[0])
		metricsOUT.write("%10i  paired in sequencing\n\n" % c[1])
		metricsOUT.write("%10i  mapped (%.2f%%)\n" % (c[2], c[2]/float(c[0])*100))
		metricsOUT.write("%10i  properly paired (%.2f%%)\n" % (c[4], c[4]/float(c[0])*100))
		metricsOUT.write("%10i  isize smaller read length (%.2f%%)\n" % (c[8], c[8]/float(c[0])*100))
		metricsOUT.write("%10i  singletons (%.2f%%)\n\n" % (c[5], c[5]/float(c[0])*100))
		if not type(args.maxnCGc) == type(False):
			metricsOUT.write("%10i  QC-fail (%.2f%%)\n" % (c[3], c[3]/float(c[0])*100))
			metricsOUT.write("%10i    illegally mapped (%.2f%%)\n" % (c[6], c[6]/float(c[0])*100))
			metricsOUT.write("%10i    >%i non-CG Cs (%.2f%%)\n" % (c[7], args.maxnCGc, c[7]/float(c[0])*100))
		else:
			metricsOUT.write("%10i  illegally mapped (%.2f%%)\n" % (c[3], c[3]/float(c[0])*100))
		
		metricsOUT.write("\n# mapped reads per contig\n")
		for tid in range(len(tidd)):
			metricsOUT.write("%10i  %s (%.2f%%)\n" % (tidd[tid], samfileOUT.getrname(tid), (tidd[tid]/float(c[2])*100)))
		
		metricsOUT.write("\n# insert size distribution\n")
		for isize in range(len(isized)):
			metricsOUT.write("%10i  %i\n" % (isized[isize], isize))
		
		metricsOUT.close()
		
	samfileIN.close()
	samfileOUT.close()

	if args.qf: sys.stderr.write("%s end: %i alignments processed\n" % (nicetime(), c[0]))


if __name__ == "__main__":
    import sys
    mod_bconv(sys.argv[1:])
	
